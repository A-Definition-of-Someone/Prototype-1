<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manage Friends</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'CommonVariables.css' %}?v=1.2">
    <link rel="stylesheet" href="{% static 'Desktop - Menu.css' %}">
    <link rel="stylesheet" href="{% static 'Desktop - Prompt - Challenge.css' %}?v=1.1">
    <link rel="stylesheet" href="{% static 'LoggedIn/Desktop - Manage Friends.css' %}?v=1.4">
    <link rel="stylesheet" href="{% static 'LoggedIn/Desktop - Prompt - Receive Challenges.css' %}?v=1.4">
    <link rel="stylesheet" href="{% static 'LoggedIn/Desktop - Prompt - Unfriend.css' %}?v=1.3">
    <link rel="shortcut icon" href="{% static 'Resources/favicon.ico' %}" type="image/x-icon">
</head>
<body>
    <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
    <form id="Prompt-Receive-Challenge" data-prompt-hidden = "true" data-dismiss="0">
        <span id="Prompt-Receive-Challenge-Header"><span>Player #2</span><span>wants to challenge you to</span></span>
        <span id="Prompt-Receive-Challenge-Config">Bullet 1 + 0</span>
        <div id="Prompt-Receive-Challenge-Gap1"></div>
        <div id="Prompt-Receive-Challenge-Operation">
            <span id="Prompt-Receive-Challenge-Operation-Decline">Decline</span>
            <input id="Prompt-Receive-Challenge-Operation-Accept" type="submit" value="Accept">
        </div>
    </form>
    <form id="Prompt-Challenge-Player" data-prompt-hidden = "true" data-target = "0">
        <span id="Prompt-Challenge-Header">Challenge Player #1 to a game of:</span>
        <div id="Prompt-Challenge-Gap1"></div>
        <div id="Prompt-Challenge-Option-Container">
            <div class="Prompt-Challenge-Option" data-chosen="true">Bullet 1 + 0</div>
            <div class="Prompt-Challenge-Option">Blitz 3 + 0</div>
            <div class="Prompt-Challenge-Option">Blitz 3 + 2</div>
            <div class="Prompt-Challenge-Option">Blitz 5 + 0</div>
            <div class="Prompt-Challenge-Option">Rapid 10 + 0</div>
            <div class="Prompt-Challenge-Option">Rapid 20 + 0</div>
        </div>
        <div id="Prompt-Challenge-Gap2"></div>
        <span id="Prompt-Challenge-SubHeader">Choose which chess side to be:</span>
        <div id="Prompt-Challenge-Side" data-chosen="White">
            <img src="{% static 'Resources/White Knight.png' %}" alt="" id="Prompt-Challenge-Side-White">
            <span id="Prompt-Challenge-Side-VS">VS</span>
            <img src="{% static 'Resources/Black Knight.png' %}" alt="" id="Prompt-Challenge-Side-Black">
        </div>
        <div id="Prompt-Challenge-Error" data-error="0" >Connection Error: Unable to reach server</div>
        <div id="Prompt-Challenge-Operation">
            <span id="Prompt-Challenge-Operation-Cancel">Cancel</span>
            <input type="submit" value="Challenge" id="Prompt-Challenge-Operation-Challenge">
        </div>
    </form>
    <form id="Prompt-Unfriend" data-prompt-hidden = "true">
        <h3>Remove Player #3 from Friend List?</h3>
        <span>Friendship should be cherished, please reconsider ü•π</span>
        <div id="Unfriend-Operation">
            <input type="submit" value="Remove Anyway" id="RemoveAnyway">
            <button id="StayAsFriends">Stay as Friends</button>
        </div>
    </form>
    <div id="MainLayout">
        {% include "Desktop - Menu.html" %}
        <div id="Header">
            <span>Welcome, {{Username}}</span>
            <span>Logout</span>
        </div>
        <form id="ManageFriends">
            <fieldset id="Friends">
                <legend>Friends</legend>
                {% for name in FriendsList %}
                <div class="Friends-Row" data-name="{{name}}"><span>{{name}}</span><button>Challenge</button><button>Unfriend</button></div>
                {% endfor %}
            </fieldset>
            <fieldset id="FriendRequests">
                <legend>Friend Requests</legend>
                {% for name in RequestList %}
                <div class="FriendRequests-Row" data-name="{{name}}"><span>{{name}}</span><button>Accept</button><button>Reject</button></div>
                {% endfor %}
            </fieldset>
            <fieldset id="SendFriendRequests">
                <legend>Send Friend Requests</legend>
                <div id="SearchRow">
                    <span>üîç</span>
                    <input type="search" aria-label="Search Player names here">
                </div>
                <div id="SendFriendRequestsContainer">
                    {% for name in PlayerList %}
                    <div class="SendFriendRequests-Row" data-name="{{name}}" data-show = "true"><span>{{name}}</span><button>Add Friend</button></div>
                    {% endfor %}
                </div>
            </fieldset>
        </form>
    </div>
    <script>
        /*csrf*/
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

        /*Menu*/
        let MenuCollapseBTN = document.getElementById("Menu-CollapseBTN");
        let Menu = document.getElementById("Menu");
        let MenuOption1 = Menu.querySelector(".Menu-Option:nth-child(3)");
        let MenuOption2 = Menu.querySelector(".Menu-Option:nth-child(4)");
        let switchCollapse = [1,0];

        MenuCollapseBTN.addEventListener("click",()=>{
            Menu.dataset.collapse = switchCollapse[Menu.dataset.collapse];
        });

        MenuOption1.addEventListener("click", ()=>{
            PromptChallengePlayer.dataset.promptHidden = "false";
            PromptChallengeHeader.innerText = "Please Choose Phantom Chess modes:";
            PromptChallengeOperationChallenge.value = "Play (Local)";
            PromptChallengePlayer.dataset.target = 0;
            PromptChallengeError.dataset.error = "0";
        });

        MenuOption2.addEventListener("click", ()=>{
            PromptChallengePlayer.dataset.promptHidden = "false";
            PromptChallengeHeader.innerText = "Please Choose Phantom Chess modes:";
            PromptChallengeOperationChallenge.value = "Play";
            PromptChallengePlayer.dataset.target = 1;
            PromptChallengeError.dataset.error = "0";
        });

        let ManageFriends = document.getElementById("ManageFriends");
        ManageFriends.addEventListener("submit",(ev)=>{
            ev.preventDefault();
        });

        /*Web Sockets*/
        /*Subscribe to Online Players List*/
        const PlayersOnlineSocket = new WebSocket(
            "ws://" +
            window.location.host +
            "/ws/OnlinePlayersList"
        );

        /*Inform other players you're online*/
        PlayersOnlineSocket.addEventListener("open", async (ev) => {
            const url = "informOnline";
            try {
                const response = await fetch(url,{
                    method: "POST",
                    headers: {'X-CSRFToken': csrftoken},
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });
                textObject = await response.text();
                console.log(textObject);
                
            } catch (error) {
                console.log("informOnline" + " " + error);
                
            }
        });

        let PlayerWebsocket = new WebSocket( //Connect to websocket dedicated to this player to listen to challenges sent by other players
            "ws://" +
            window.location.host +
            "/ws/Challenge/" + 
            "{{Username}}" +//This belongs to django template
            "/"
        )

        PlayerWebsocket.addEventListener("message",(ev)=>{
            console.log("Receive player challenges, accepts, and declines");
            const data = JSON.parse(ev.data);
            let event = data["event"];
            let sender = data["sender"];
            let gamemode = data["gamemode"];
            let senderside = data["senderside"];
            if (event === "Challenge Send"){
                document.addEventListener("click", checkOutOfBounds);
                PromptReceiveChallengeHeaderSpan.innerText = sender;
                PromptReceiveChallengeConfig.innerText = gamemode;
                PromptReceiveChallenge.dataset.promptHidden = "false";
            }else if (event === "Challenge Cancelled"){
                document.removeEventListener("click", checkOutOfBounds);
                PromptReceiveChallenge.dataset.dismiss = 0;
                PromptReceiveChallenge.dataset.promptHidden = "true";
            }else if (event === "Challenge Accepted"){
                window.location.replace("PlayMultiplayer");
            }
            console.log("PlayerWebSocket" + " " + event)
        });
        let OpponentPlayerWebSocket = null;
        let OpenLobbyWebsocket = null;

        let FriendWebSocket = new WebSocket(
            "ws://" +
            window.location.host +
            "/ws/Friend/" + 
            "{{Username}}" +//This belongs to django template
            "/"
        );

        FriendWebSocket.addEventListener("message", async (ev)=>{
            const data = JSON.parse(ev.data);
            console.log("FriendWebSocket" + " " + data["event"]);
            if(data["event"] === "friend_request"){
                //Fetch Friend Request List
                const url = "getFriendRequestList";
                try {
                    const response = await fetch(url,{
                        method: "POST",
                        headers: {'X-CSRFToken': csrftoken},
                        mode: 'same-origin' // Do not send CSRF token to another domain.
                    });
                    jsonObject = await response.json();
                    console.log("FriendRequestWebSocket" + " " + jsonObject["FriendRequests"] );
                    let FriendRequestList = Array.from(jsonObject["FriendRequests"] || []);
                    SendFriendRequestsContainer.removeChild(
                        SendFriendRequestsContainer.querySelector(".SendFriendRequests-Row[data-name=\"" + data["sender"] +"\"]")
                    );
                    //Array.from(FriendRequestsContainer || []).forEach(request=>FriendRequestsContainer.removeChild(request));
                    FriendRequestList.forEach(name=> FriendRequestsContainer.appendChild(createFriendRequestsRow(name)));
                } catch (error) {
                    console.log("FriendRequestWebSocket" + " " + error);
                }
            }
            else if(data["event"] === "friend_added"){
                 Friends.appendChild(createFriendRow(data["sender"]));
            }
            else if(data["event"] === "friend_rejected"){
                let row = createSendFriendRequestsRow(data["sender"]);
                SendFriendRequestsContainer.appendChild(row);
                SendFriendRequestsRows.push(row); //Update row list so search the same thing again doesnt result in appending new rows
            }
            else if(data["event"] === "friend_removed"){
                //Remove from friend list
                Friends.removeChild(Friends.querySelector(".Friends-Row[data-name=\""+ data["sender"] +"\"]"));
                //Return it to send friend request list
                let row = createSendFriendRequestsRow(data["sender"]);
                SendFriendRequestsContainer.appendChild(row);
                SendFriendRequestsRows.push(row); //Update row list so search the same thing again doesnt result in appending new rows
            }
        });

        /*Log Out*/
        let authButton = document.querySelector("#Header span:nth-child(2)");
        authButton.addEventListener("click", justTriggerLogout);

        /*Prompt-Unfriend*/
        let PromptUnfriend = document.getElementById("Prompt-Unfriend");
        let PromptUnfriendTitle = PromptUnfriend.querySelector("h3");
        let PromptUnfriendPlead = PromptUnfriend.querySelector("span");
        let PromptUnfriendRemove = PromptUnfriend.querySelector("#Unfriend-Operation #RemoveAnyway");
        let PromptUnfriendStay = PromptUnfriend.querySelector("#Unfriend-Operation #StayAsFriends");

        PromptUnfriend.addEventListener("submit",(ev)=>{
            ev.preventDefault();
            PromptUnfriend.dataset.promptHidden = "true";
        });
        PromptUnfriendRemove.addEventListener("click", RemoveFriend);

        /*Friends*/
        let Friends = document.getElementById("Friends");
        let FriendsRows = Array.from(Friends.querySelectorAll(".Friends-Row") || []);
        let FriendsBtnsChallenge = Array.from(Friends.querySelectorAll(".Friends-Row button:nth-child(2)") || []);
        let FriendsBtnsUnfriend = Array.from(Friends.querySelectorAll(".Friends-Row button:nth-child(3)") || []);

        FriendsBtnsChallenge.forEach(btn=>btn.addEventListener("click",ChallengeFriend.bind(btn)));
        FriendsBtnsUnfriend.forEach(btn=>btn.addEventListener("click", TriggerUnfriendPrompt.bind(btn)));

        /*Friend Requests*/
        let FriendRequestsContainer = document.getElementById("FriendRequests");
        let FriendRequestsRows = Array.from(FriendRequestsContainer.querySelectorAll(".FriendRequests-Row") || []);
        let FriendRequestsBtnsAccept = Array.from(FriendRequestsContainer.querySelectorAll(".FriendRequests-Row button:nth-child(2)") || []);
        let FriendRequestsBtnsDecline = Array.from(FriendRequestsContainer.querySelectorAll(".FriendRequests-Row button:nth-child(3)") || []);

        FriendRequestsBtnsAccept.forEach(btn=>btn.addEventListener("click", AcceptFriend.bind(btn)));
        FriendRequestsBtnsDecline.forEach(btn=>btn.addEventListener("click", RejectFriend.bind(btn)));

        /*Send Friend Requests*/
        let Search = document.querySelector("#SearchRow input[type=\"search\"]");
        let SendFriendRequestsContainer = document.getElementById("SendFriendRequestsContainer");
        let SendFriendRequestsRows = Array.from(SendFriendRequestsContainer.querySelectorAll(".SendFriendRequests-Row") || []);
        let SendFriendRequestsBtns = Array.from(SendFriendRequestsContainer.querySelectorAll(".SendFriendRequests-Row button") || []);

        SendFriendRequestsBtns.forEach(btn=>btn.addEventListener("click", RequestFriend.bind(btn)));
        Search.addEventListener("input", Searching);
        

        /*Prompt Challenge*/
        let PromptChallengePlayer = document.getElementById("Prompt-Challenge-Player");
        let PromptChallengeHeader = document.getElementById("Prompt-Challenge-Header");
        let PromptChallengeOperationCancel = document.getElementById("Prompt-Challenge-Operation-Cancel");
        let PromptChallengeOperationChallenge = document.getElementById("Prompt-Challenge-Operation-Challenge");
        let PromptChallengeSide = document.getElementById("Prompt-Challenge-Side");
        let PromptChallengeSideWhite = document.getElementById("Prompt-Challenge-Side-White");
        let PromptChallengeSideBlack = document.getElementById("Prompt-Challenge-Side-Black");
        let PromptChallengeError = document.getElementById("Prompt-Challenge-Error");
        let PromptChallengeAction = [challengeLocally, challengeGlobally, challengePlayer];
        let PromptChallengeOptionContainer = document.getElementById("Prompt-Challenge-Option-Container");

        PromptChallengeOptionContainer.addEventListener("click", (ev)=>{
            if(ev.target.classList[0] === "Prompt-Challenge-Option"){
                let PromptChallengeChosen = document.querySelector(".Prompt-Challenge-Option[data-chosen=\"true\"]");
                PromptChallengeChosen.dataset.chosen = "false";
                ev.target.dataset.chosen = "true";
            }
        });

        PromptChallengeSideWhite.addEventListener("click", ()=> PromptChallengeSide.dataset.chosen = "White");
        PromptChallengeSideBlack.addEventListener("click", ()=> PromptChallengeSide.dataset.chosen = "Black");

        PromptChallengePlayer.addEventListener("submit", async (ev)=>{
            ev.preventDefault();
            let PromptChallengeChosen = document.querySelector(".Prompt-Challenge-Option[data-chosen=\"true\"]");
            await PromptChallengeAction[PromptChallengePlayer.dataset.target](PromptChallengePlayer.Username, PromptChallengeChosen.innerText);
        });

        PromptChallengeOperationCancel.addEventListener("click",()=>{
            PromptChallengePlayer.dataset.promptHidden = "true";
            PromptChallengeError.dataset.error = "0";
            if (OpponentPlayerWebSocket instanceof WebSocket){
                //Inform the challenged player, the challenge's off
                OpponentPlayerWebSocket.send("Cancel");
            }
            if (OpenLobbyWebsocket instanceof WebSocket){
                OpenLobbyWebsocket.close(4001);
            }
        });

        /*Prompt Receive Challenge*/
        let PromptReceiveChallenge = document.getElementById("Prompt-Receive-Challenge");
        let PromptReceiveChallengeHeaderSpan = PromptReceiveChallenge.querySelector("#Prompt-Receive-Challenge-Header span");
        let PromptReceiveChallengeConfig = PromptReceiveChallenge.querySelector("#Prompt-Receive-Challenge-Config");
        let PromptReceiveChallengeOperationDecline = PromptReceiveChallenge.querySelector("#Prompt-Receive-Challenge-Operation-Decline");

        //Add event listener for cancel and challenge button
        PromptReceiveChallengeOperationDecline.addEventListener("click",()=>{
            //Hide the receive challenge prompt
            PromptReceiveChallenge.dataset.promptHidden = "true";
            PlayerWebsocket.send("Reject");
        });
        PromptReceiveChallenge.addEventListener("submit",(ev)=>{
            ev.preventDefault();
            PromptReceiveChallenge.dataset.promptHidden = "true";
            PlayerWebsocket.send("Accept");
        });

        /*Functions*/

        function ChallengeFriend(){
            Username = this.parentElement.dataset.name;
            PromptChallengePlayer.Username = Username;
            PromptChallengeError.dataset.error = "0";
            PromptChallengePlayer.dataset.promptHidden = "false";
            PromptChallengeHeader.innerText = "Challenge " + Username + " to a game of:";
            PromptChallengeOperationChallenge.value = "Challenge";
            PromptChallengePlayer.dataset.target = 2; // Challenge Player
        }

        function TriggerUnfriendPrompt(){
            PromptUnfriend.dataset.promptHidden = "false";
            PromptUnfriend.PlayerName = this.parentElement.dataset.name;
            PromptUnfriendTitle.innerText = "Remove "+ PromptUnfriend.PlayerName +" from Friend List?";
        }

        async function RemoveFriend(){
            const url = "Unfriend";
            let formData = new FormData();
            let PlayerName = PromptUnfriend.PlayerName;
            formData.append("PotentialFriendName", PlayerName);
            try {
                const response = await fetch(url,{
                    method: "POST",
                    headers: {
                        'X-CSRFToken': csrftoken,
                    },
                    body:formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const textObject = await response.text();
                
                //Remove from friend list
                Friends.removeChild(Friends.querySelector(".Friends-Row[data-name=\""+ PlayerName +"\"]"));

                //Add back to send request friend list
                let row = createSendFriendRequestsRow(PlayerName);
                SendFriendRequestsContainer.appendChild(row);
                SendFriendRequestsRows.push(row); //Update row list so search the same thing again doesnt result in appending new rows
                
                console.log("RemoveFriend" + " " + textObject);
            
            } catch (error) {
                console.log("RemoveFriend" + " " + error);
            }
        }

        function Searching(ev = new InputEvent()){
            console.log(Searching.name);
            let searchResult = -1;
            let foundStatus = false;
            //Search in the rows first
            SendFriendRequestsRows.forEach(Row=>{
                searchResult = String(Row.dataset.name).search(new RegExp(ev.target.value, "i"));
                if(searchResult === -1){
                    Row.dataset.show = "false"; //Hide irrelevant rows
                }else{
                    Row.dataset.show = "true"; //Show relevant rows
                    foundStatus = true;
                }
            });
            //If in the rows are not available, only then send query to Database
            if (!foundStatus){
                queryPlayersNames(ev.target.value).then(list=>{
                    list.forEach(name=>{
                        let row = createSendFriendRequestsRow(name);
                        SendFriendRequestsContainer.appendChild(row);
                        SendFriendRequestsRows.push(row); //Update row list so search the same thing again doesnt result in appending new rows
                    });
                });
            }

        }

        async function RequestFriend(ev){
            const url = "sendFriendRequest";
            let formData = new FormData();
            formData.append("PotentialFriendName", this.parentElement.dataset.name);
            try {
                const response = await fetch(url,{
                    method: "POST",
                    headers: {
                        'X-CSRFToken': csrftoken,
                    },
                    body:formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const textObject = await response.text();
                
                    //Remove from send friend request list
                    let Container = this.parentElement.parentElement;
                    Container.removeChild(this.parentElement);
                
                console.log("RequestFriend" + " " + textObject);
            
            } catch (error) {
                console.log("RequestFriend" + " " + error);
            }
        }

        async function AcceptFriend(ev){
            const url = "AcceptFriendRequest";
            let formData = new FormData();
            formData.append("PotentialFriendName", this.parentElement.dataset.name);
            try {
                const response = await fetch(url,{
                    method: "POST",
                    headers: {
                        'X-CSRFToken': csrftoken,
                    },
                    body:formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const textObject = await response.text();
                
                    //Remove from friend request list
                    let Container = this.parentElement.parentElement;
                    Container.removeChild(this.parentElement);

                //Move to friend list
                if(textObject === "Friend Request Sent!"){
                    Friends.appendChild(createFriendRow(this.parentElement.dataset.name))
                }
                
                console.log("AcceptFriend" + " " + textObject);
            
            } catch (error) {
                console.log("AcceptFriend" + " " + error);
            }
        }

        async function RejectFriend(ev) {
            const url = "RejectFriendRequest";
            let formData = new FormData();
            formData.append("PotentialFriendName", this.parentElement.dataset.name);
            try {
                const response = await fetch(url,{
                    method: "POST",
                    headers: {
                        'X-CSRFToken': csrftoken,
                    },
                    body:formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const textObject = await response.text();
                
                    //Remove from friend request list
                    let Container = this.parentElement.parentElement;
                    Container.removeChild(this.parentElement);

                //Move to send friend request list
                if(textObject === "Friend Rejection Sent!"){
                    let row = createSendFriendRequestsRow(this.parentElement.dataset.name);
                    SendFriendRequestsContainer.appendChild(row);
                    SendFriendRequestsRows.push(row); //Update row list so search the same thing again doesnt result in appending new rows
                }
                
                console.log("RejectFriend" + " " + textObject);
            
            } catch (error) {
                console.log("RejectFriend" + " " + error);
            }
        }

        async function queryPlayersNames(PlayerName = ""){
            console.log(queryPlayersNames.name + "Name Searched = " + PlayerName);
            const url = "queryPlayersNames";
            let formData = new FormData();
            formData.append("PotentialFriendName", PlayerName);
            let list = [];
            try {
                const response = await fetch(url,{
                    method: "POST",
                    headers: {
                        'X-CSRFToken': csrftoken,
                    },
                    body:formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const jsonObject = await response.json();
                list = Array.from(jsonObject.Names || []);
                console.log(queryPlayersNames.name + " Print: " + list.toString());
            } catch (error) {
                console.log(queryPlayersNames.name + " " + error);
                
            }
            return list;
        }

        function createSendFriendRequestsRow(PlayerName){
            let row = document.createElement("div");
            let span = document.createElement("span");
            let button = document.createElement("button");

            row.classList.add("SendFriendRequests-Row");
            row.dataset.name = PlayerName;
            row.dataset.show = "true";
            span.innerText = PlayerName;
            button.innerText = "Add Friend";
            button.addEventListener("click", RequestFriend.bind(button));

            row.appendChild(span);
            row.appendChild(button);

            return row;
        }

        function createFriendRequestsRow(PlayerName){
            let row = document.createElement("div");
            let span = document.createElement("span");
            let buttonAccept = document.createElement("button");
            let buttonReject = document.createElement("button");

            row.classList.add("FriendRequests-Row");
            row.dataset.name = PlayerName;
            row.dataset.show = "true";
            span.innerText = PlayerName;
            buttonAccept.innerText = "Accept";
            buttonReject.innerText = "Reject";
            buttonAccept.addEventListener("click", AcceptFriend.bind(buttonAccept));
            buttonReject.addEventListener("click", RejectFriend.bind(buttonReject));

            row.appendChild(span);
            row.appendChild(buttonAccept);
            row.appendChild(buttonReject);

            return row;
        }

        function createFriendRow(PlayerName){
            let row = document.createElement("div");
            let span = document.createElement("span");
            let buttonChallenge = document.createElement("button");
            let buttonUnfriend = document.createElement("button");

            row.classList.add("Friends-Row");
            row.dataset.name = PlayerName;
            row.dataset.show = "true";
            span.innerText = PlayerName;
            buttonChallenge.innerText = "Challenge";
            buttonUnfriend.innerText = "Unfriend";
            buttonChallenge.addEventListener("click", ChallengeFriend.bind(buttonChallenge));
            buttonUnfriend.addEventListener("click", TriggerUnfriendPrompt.bind(buttonUnfriend));

            row.appendChild(span);
            row.appendChild(buttonChallenge);
            row.appendChild(buttonUnfriend);

            return row;
        }

        async function challengeLocally(){
            const url = "PlayLocal";
            let formData = new FormData();
            formData.append("PlayerUsername", "Player #1");
            formData.append("Gamemode", document.querySelector(".Prompt-Challenge-Option[data-chosen=\"true\"]").innerText);
            formData.append("Side", PromptChallengeSide.dataset.chosen);
            formData.append("csrfmiddlewaretoken", csrftoken);
            
            try {
                const response = await fetch(url, {
                    method: "POST",
                    body: formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const textObject = await response.text();
                if(textObject !== "OK"){
                    PromptChallengeError.innerText = textObject;
                    PromptChallengeError.dataset.error = "1";
                }else{
                    window.location.replace("PlayLocal");
                }

            } catch (error) {
                PromptChallengeError.innerText = "Unable to send response!";
                PromptChallengeError.dataset.error = "1";
            }
        }

        async function challengeGlobally(){
            const url = "searchOpponent";
            let formData = new FormData();
            formData.append("Gamemode", document.querySelector(".Prompt-Challenge-Option[data-chosen=\"true\"]").innerText);
            formData.append("Side", PromptChallengeSide.dataset.chosen);
            formData.append("csrfmiddlewaretoken", csrftoken);
            try {
                const response = await fetch(url, {
                    method: "POST",
                    body: formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const textObject = await response.text();
                if(textObject === "Match Found!"){
                    PromptChallengeError.innerText = textObject;
                    PromptChallengeError.dataset.error = "2";
                    window.location.replace("PlayMultiplayer");
                } else if(textObject === "Open Lobby"){
                    PromptChallengeError.innerText = textObject;
                    PromptChallengeError.dataset.error = "2";
                    //Open Lobby Web Socket first
                    OpenLobbyWebsocket = new WebSocket( //Connect to websocket dedicated to this player to listen to challenges sent by other players
                        "ws://" +
                        window.location.host +
                        "/ws/Matchmaking/" + 
                        "{{Username}}" + //This belongs to django template
                        "/");
                    OpenLobbyWebsocket.addEventListener("message",(ev)=>{
                            const data = JSON.parse(ev.data);
                            PromptChallengeError.innerText = data["event"] + ": " + data["sender"];
                            PromptChallengeError.dataset.error = "2";
                            window.location.replace("PlayMultiplayer");
                        });
                    //Open lobby
                    openLobby();
                }
                else{
                    PromptChallengeError.innerText = textObject;
                    PromptChallengeError.dataset.error = "1";
                }
            } catch (error) {
                PromptChallengeError.innerText = "Unable to send response!" + " " + error;
                PromptChallengeError.dataset.error = "1";
            }
        }

        async function openLobby() {
            const url = "openLobby";
            let formData = new FormData();
            formData.append("Gamemode", document.querySelector(".Prompt-Challenge-Option[data-chosen=\"true\"]").innerText);
            formData.append("Side", PromptChallengeSide.dataset.chosen);
            formData.append("csrfmiddlewaretoken", csrftoken);

            try {
                const response = await fetch(url, {
                    method: "POST",
                    body: formData,
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const textObject = await response.text();
                if(textObject !== "Lobby Opened"){
                    PromptChallengeError.innerText = textObject;
                    PromptChallengeError.dataset.error = "1";
                }
            } catch (error) {
                PromptChallengeError.innerText = textObject;
                PromptChallengeError.dataset.error = "1";
            }
        }

        async function challengePlayer(Username, Gamemode){
            console.log("challengePlayer");
            OpponentPlayerWebSocket = new WebSocket( //Connect to websocket dedicated to this player to listen to challenges sent by other players
                "ws://" +
                window.location.host +
                "/ws/Challenge/" + 
                Username + "/"
            );

            OpponentPlayerWebSocket.addEventListener("message", (ev)=>{
                const data = JSON.parse(ev.data);
                if (data["event"] === "Challenge Cancelled"){
                    //Inform challenge rejection
                    PromptChallengeError.innerText = "Challenge Rejected by " + data["sender"];
                    PromptChallengeError.dataset.error = "1";
                }else if (data["event"] === "Challenge Accepted"){
                    //Inform challenge aceptance
                    PromptChallengeError.innerText = "Challenge Accepted by " + data["sender"];
                    PromptChallengeError.dataset.error = "2";
                    window.location.replace("PlayMultiplayer");
                }
            });

            OpponentPlayerWebSocket.addEventListener("open", (ev)=>{
                console.log("OpponentPlayerWebSocket opened!");
                
                OpponentPlayerWebSocket.send(JSON.stringify({
                "Gamemode": Gamemode,
                "SenderSide": PromptChallengeSide.dataset.chosen
            }));
            });
        }

        async function justTriggerLogout(){
            const url = "/AuthLogout";
            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: {'X-CSRFToken': csrftoken},
                    mode: 'same-origin' // Do not send CSRF token to another domain.
                });

                const jsonObject = await response.json();
                if (jsonObject.Status === "Logout Success"){
                    window.location.replace("");
                }
                console.log("Logout Remark: " + jsonObject.Remark);
                
            } catch (error) {
                console.log("justTriggerLogout" + " " + error);
            }
        }

        function checkOutOfBounds(ev){
            if(!PromptReceiveChallenge.contains(ev.target)){
                PromptReceiveChallenge.dataset.dismiss = 1;
            }
        }
    </script>
</body>
</html>